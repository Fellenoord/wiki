{"/":{"title":"Index","data":{"":"Welcome to the WebCieWiki, this is a central place for all the information about the great WebCie rewrite of 2022-2023. This is a work in progress, so please be patient. If you have any questions, please contact the WebCie.At the moment, this wiki mostly contains tutorials about various aspects of the rewrite. Currently, you can find tutorials about:\nSetting up your development environment\nLearning how to program and language-specific skills\nLearning about our workflow"}},"/learning/backend":{"title":"Backend","data":{"":"Please only start here if you are familiar with both TypeScript and Node.js. If you are not, please refer to our programming skills section first.","have-never-done-any-backend-development-in-nodejs-before#Have never done any backend development in Node.js before":"While you might already be somewhat familiar with backend development if you've used things like Python Django/Flask, Java Spring, or Ruby on Rails, you might not have done any backend development in Node.js before. If that's the case, you should know that the simplest form of backend development in Node.js happens in the form of a HTTP server. This is a server that listens for HTTP requests and responds to them. The most common way to do this is with the Express framework. As such, we recommend to familiarize yourself with the basic concepts of an HTTP server and Express before continuing. Here are some resources:\nExpress documentation\nFull Stack course - Express\n\nNote that the course above uses MongoDB to store data, but we are using PostgreSQL. I recommend skipping the MongoDB part and just focusing on the Express part. You probably don't need to know a lot about databases to get started with this project, but we will handle this in a bit more detail in the next section.","have-used-nodejs-before#Have used Node.js before":"If you have used Node.js before for backend development, you have probably used either Express, or a similar framework. This section will mainly focus on becoming familiar with the structure of our backend and the main libraries we are using. Here are some resources about the libraries we are using:\nNestJS\nPrisma\nGraphQL\nFull Stack course - GraphQL\n\nFor NestJS, it is important to familiarize yourself with the basic structure of modules, services, controllers, and resolvers. For Prisma, it is important to familiarize yourself with the API and how to use it. For GraphQL, it is important to familiarize yourself with the basic concepts of GraphQL and how to write queries and mutations.","where-to-go-from-here#Where to go from here":"Now that you know the basics about the backend, you can either go to the frontend section if you are more interested in the website or you can go to the git section if you want to learn how to start contributing to the project."}},"/learning/frontend":{"title":"Frontend","data":{"":"Please only start here if you are familiar with both TypeScript and Node.js. If you are not, please refer to our programming skills section first.","have-never-used-react-before#Have never used React before":"Whether you have already made websites using vanilla JavaScript and HTML, used Vue before or have not made any website before, you can start here. Since our frontend is built with React, you will need to learn React before you can start contributing to the frontend. Here are some resources to get you started:\nReact Documentation\nFull Stack course\n\nWhile the React docs should be enough to familiarize yourself with React, the Full Stack course can be a great, but exhaustive resource to learn everything about React and web development in general. Not all parts of the course are relevant, and some parts cover some more basic concepts that you might already know (like HTTP requests), you can always skip those parts. Do note that the first parts are all in JavaScript, there is a part specifically about TypeScript (part 9) but in general, TypeScript does not differ much from JavaScript when it comes to React. Also keep in mind the prerequisites for the course, you will need to know some basic programming and Git.","have-used-react-before#Have used React before":"If you have already used React (preferably with TypeScript) before, you don't need to learn a whole lot extra. We are using Next.js as our framework of choice, which is a React framework that adds some extra features like server-side rendering and routing. To learn more about Next.js, we recommend the official documentation as well as their tutorial. The tutorial is a great way to get started with Next.js, but you can also just read the documentation if you prefer that. Keep in mind the tutorial does not use TypeScript, but the difference between TypeScript and JavaScript is not that big when it comes to React.","have-used-nextjs-before#Have used Next.js before":"If you have already used Next.js before and feel comfortable with it (including using it with TypeScript), you should be good to go. If you have used Next.js before but it was a while ago, make sure to read the documentation again to make sure you are familiar with the latest version of Next.js (we are using Next 13 at the time of writing).","where-to-go-from-here#Where to go from here":"Once you have familiarized yourself with Next.js, you might want to read up on some major frontend libraries we are using in the project. These are:\nChakra UI - our UI library\nApollo Client - our GraphQL client\nReact Hook Form - our form library\n\nOtherwise, you can start looking at the git section to learn how to contribute to the project."}},"/learning/git":{"title":"Git","data":{"":"Now that you are familiar with at least the basics of our project, you should also know how you can start contributing to our project. For this, we use a versioning control system called Git. Git is like Google Drive for code. It allows you to keep track of changes to your code and allows you to collaborate with other developers. Even though you might already be familiar with Git, we recommend you at least read the last section to get a better understanding of how we use Git.","have-never-used-any-versioning-control-system-before#Have never used any versioning control system before":"There's a lot that can be learned about versioning control systems in general, but to understand the basics, you should at least know the following:\nLearn Git Branching\nGit Book\nSet up Git","have-used-git-before#Have used Git before":"Even though you might already be familiar with Git, there are still some particularities that you should know about our project. First of all, we use GitHub as our hosting platform of choice, meaning you should create a GitHub account (if you have not already) and request access to our repositories. You should also become familiar with our workflow, which can be found in our workflow section."}},"/learning":{"title":"Index","data":{"":"Depending on your level of competence, you might already be familiar with some programming concepts or languages. For each area, we will make some distinctions in your skill level to make sure you know enough to get started.\nMake sure to have reached the last level of programming skills before continuing with frontend, and backend skills.","skills#Skills":"Programming skills\nFrontend skills\nBackend skills\nGit skills","programming-skills#Programming skills":"Never programmed before in my life\nHave done some programming, whether it be in JavaScript, TypeScript or another language\nHave used TypeScript in combination with Node.js before","backend-skills#Backend skills":"Have never done any backend development with Node.js before\nHave used Node.js before","frontend-skills#Frontend skills":"Have never used React before\nHave used React before, but not Next.js\nHave used Next.js before","git-skills#Git skills":"Have never used any versioning control system before\nHave used Git / GitHub before"}},"/setup/docker":{"title":"Docker","data":{"":"The use of Docker is recommended, since this removes the need to set up databases and other dependencies locally.To get started with Docker, download and install Docker Desktop.\nIt is also possible to set up Docker without Docker Desktop, but we will not cover that here.\nIf you're using WSL, make sure to check the Use the WSL 2 based engine option in Docker Desktop's settings."}},"/setup/git":{"title":"Git","data":{"":"","installation#Installation":"Git should already be installed on your Linux distribution. You can check by using git --version in the command line. However if it's not installed do so using:\nsudo apt-get install git\n\n\nGit should already be installed on your MacOS version. You can check by using git --version in the command line. However if it's not installed do so using:\nbrew install git","configuration#Configuration":"The Git config can be found at ~/.gitconfig, but can also be setup using the command line. Let's set a global name and email (removing the --global tag can set up local configuration per repository).\ngit config --global user.name \"Your Name\"\nGitHub gives you a no-reply email for your account, which I recommend you use to hide your real email. For more info look here.\ngit config --global user.email \"<id>+<username>@users.noreply.github.com\"","accessing-the-remote#Accessing the remote":"To access the remote repository, you need to set up an SSH key. This is a public/private key pair that allows you to authenticate with the remote server without having to enter your password every time. You can read more about SSH keys here.","generating-a-ssh-key#Generating a SSH key":"To generate a new SSH key we use ssh-keygen.\nMake sure to use the no-reply email if available.\n\nssh-keygen -t ed25519 -C \"<id>+<username>@users.noreply.github.com\"","adding-the-key-to-the-ssh-agent#Adding the key to the ssh-agent":"Next, we add our key to the ssh-agent to manage our keys. Start the ssh-agent in the background:\nexec ssh-agent bash\nThen add your private key.\n\n\nssh-add ~/.ssh/id_ed25519\nUse cat ~/.ssh/id_ed25519.pub to show your public key, and finally add it to your GitHub account.\n\n\nssh-add ~/.ssh/id_ed25519\nMake sure to also add the host to your ~/.ssh/config file:\nHost github.com\nAddKeysToAgent yes\nUseKeychain yes\nIdentityFile ~/.ssh/id_ed25519\nUse pbcopy < ~/.ssh/id_ed25519.pub to copy your public key, and finally add it to your GitHub account.","signed-commits#Signed commits":"Though this is highly optional, signing your commits proves that you are the author of the commit.","generating-a-gpg-key#Generating a GPG key":"To be able to sign a commit we need a GPG key. Let's generate one:\ngpg --full-generate-key\nThen we select the following options: RSA and RSA (default), 4096 bits and 0. Then enter the same name, and email as before (again the no-reply email is best). Finally, you are asked for a passphrase.Use the gpg --list-secret-keys --keyid-format=longcommand to list the long form containing both public and private key. We require the private key to sign commits. From that list, we copy the long form of the GPG key ID (example: 3AA5C34371567BD2) in:\ngpg --list-secret-keys --keyid-format=long\n/Users/hubot/.gnupg/secring.gpg\n------------------------------------\nsec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]\nuid                          Hubot <hubot@example.com>\nssb   4096R/4BB6D45482678BE3 2016-03-10\nThen to print the full GPG key ID in ASCII armor format:\ngpg --armor --export 3AA5C34371567BD2\nCopy your GPG key, beginning with -----BEGIN PGP PUBLIC KEY BLOCK----- and ending with -----END PGP PUBLIC KEY BLOCK-----. Add it to your GitHub account.","signing-your-commits#Signing your commits":"First, make sure to tell Git which signing key to use (obviously use your own):\ngit config --global user.signingkey 3AA5C34371567BD2\nthen add export GPG_TTY=$(tty) to your ~/.bashrc or ~/.zshrc file and restart your terminal. Then to sign commits we add the -S when using git commit:\n$ git commit -S -m \"YOUR_COMMIT_MESSAGE\"\nHowever, it is easier to configure Git to always sign your commits. We do this by updating the Git configuration again:\ngit config --global commit.gpgsign true"}},"/setup/ide":{"title":"Ide","data":{"":"Arguably the most important part of the setup is your development environment, the place where you'll actually be writing code. For this, we use a so called \"IDE\" or \"Integrated Development Environment\". For web development, there are 2 popular options: Visual Studio Code and WebStorm. While both work fine, we recommend using VSCode since it's free and has better support for extensions in the case of our project. The final choice, however, is up to you.","visual-studio-code#Visual Studio Code":"Visual Studio Code, also known as just VSCode, is a free, open-source IDE developed by Microsoft. It's available for Windows, macOS and Linux and is the most popular IDE for web development. To start, download the installer from the official website and install it.","extensions#Extensions":"VSCode has a built-in extension marketplace, where you can find and install extensions for the IDE. We recommend installing the following extensions:\nWSL (when using WSL)\nPrettier - Code formatter\nPrettier ESLint\nESLint\nDocker\nPrisma\nPostgreSQL\nGraphQL: Language Feature Support\nGraphQL: Syntax Highlighting\nLive Share\n\nThese extensions should allow for an easier time when working on our project, we'll quickly go over what they do:\nWSL: This extension allows you to use VSCode as your IDE for WSL, it is very much recommended to use this extension when using VSCode and WSL in any capacity.\nPrettier: This extension allows you to automatically format your code to a consistent style. This is very useful for our project, since we have a strict code style that we follow.\nESLint: This extension allows you to automatically lint your code, which means it will automatically check for errors and inconsistencies in your code. This is also very useful for our project, since we have a strict code style that we follow.\nDocker: This extension allows you to easily manage Docker containers and images from within VSCode. Can be useful but not a requirement since Docker Desktop does the same thing.\nPrisma: This extension allows you to easily manage Prisma schemas and migrations from within VSCode. Very much recommended if you need to adjust the database schema.\nPostgreSQL: This extension allows you to easily manage PostgreSQL databases from within VSCode. Useful if you want to manually query the database.\nGraphQL: This extension allows you to write and format GraphQL queries and mutations. Very much recommended if you are writing any GraphQL code in the frontend.\nLive Share: This extension allows you to share your VSCode instance with other people, allowing you to work together on the same code. Very useful if you want to work together with other people on the project or if you need any (remote) help.","recommended-settings#Recommended settings":"To make VSCode work best with our project, we recommend changing the following settings:\nEditor: Format on Save: This setting will automatically format your code when you save it. This is very useful for our project, since we have a strict code style that we follow.\nProject-specific settings: Both the frontend and backend repositories contain a .vscode folder with additional settings that are specific to that project. These settings are automatically applied when opening the project in VSCode, so you don't have to do anything.","tips#Tips":"Use WSL: We recommend using WSL for development, since it allows you to use the same development environment on all platforms. If you are using WSL, make sure to install the WSL extension for VSCode. When opening a folder in VSCode, you can open it from WSL by pressing \"F1\" and typing \"Open Folder in WSL\", this is way faster than opening the folder in Windows.\nDon't be afraid to use the Git tab: Newcomers might have some difficulty in using command-line Git, so we recommend using the built-in Git support in VSCode. To use Git in VSCode, simply open the Git tab in the left sidebar, from here you can commit, push, pull, etc. This works even better if you combine it with VSCode workspaces (see below).\nCreate a workspace for the project: VSCode allows you to create a workspace for a project, which allows you to easily open the project in VSCode. This is very useful if you are working on multiple projects at the same time, since you can easily switch between them. To create a workspace, simply open the project folder in VSCode and click on \"Add Folder to Workspace\" in the bottom left corner.\nFind useful extensions: VSCode has a built-in extension marketplace, where you can find and install extensions for the IDE. We recommend installing the extensions mentioned above, but you can also find other useful extensions there. For example, you can find extensions for syntax highlighting for other languages, such as Python, C++, etc.\nPersonalize VSCode: VSCode is highly customizable, you can change the color theme, the font, the keybindings, etc. You can also install extensions that allow you to customize the UI, such as Material Icon Theme and Material Theme.","webstorm#WebStorm":"😬"}},"/setup":{"title":"Index","data":{"":"This entire wiki assumes the use of an unix-based system. If you are using MacOS this requires no further setup, however, for Windows the Windows Subsystem for Linux (WSL) is encouraged.A guide to setup WSL can be found here. For MacOS look here."}},"/setup/macos":{"title":"macOS","data":{"":"","command-line-tools#Command Line tools":"As a MacOS developer you need have the Xcode Command Line Tools installed.\nxcode-select --install","homebrew#Homebrew":"When using MacOS it is recommended to use the Homebrew package manager. It installs stuff using the command line. To install homebrew simply run the following:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""}},"/setup/nodejs":{"title":"Nodejs","data":{"":"When using Node.js it recommended to use the Node Version Manager (NVM) to quickly install and use different versions of node via the command line.\n\n\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n\n\n\nbrew install nvm\n\n\nThen, after reopening the terminal, use nvm --version to check if it has installed properly. Finally, we can install the latest version of Node using nvm install --lts."}},"/setup/others":{"title":"Others","data":{"":"There are a few more programs that can be of use when working on the project. We'll briefly discuss them here and explain how they can be used.","github-desktop#GitHub Desktop":"Can be downloaded from here. GitHub Desktop can be seen as an alternative to the Git CLI (command line interface). It is a graphical user interface that allows you to interact with GitHub without having to use the command line. It is a very useful tool for beginners, but it is not necessary to use it. You can use the Git CLI or the Git tab in VSCode instead.","altair-graphql-client#Altair GraphQL Client":"Can be downloaded from here. If you have ever interacted with a REST API before, you might have used something like Postman or Insomnia. Altair is like those 2 programs but for GraphQL. While Postman and Insomnia do support GraphQL, Altair has some additional features that just makes it easier to work with GraphQL. With Altair, you'll be able to write and execute GraphQL queries to the backend, you can also see the schema of the backend and the documentation of the queries and mutations. It is a must have if you want to test your queries seperately from the frontend. While you can download it as a Windows application, we recommend downloading the browser extension instead, we have had some issues with authentication when using the Windows application.","prisma-studio#Prisma Studio":"Not as much as a desktop tool as a simple script, Prisma Studio allows you to introspect your schema and explore your database from the browser. It can be useful to quickly see database data, but it is not very advanced. You can read about it here, to run it, simply open the backend folder in VSCode and run npx prisma studio in the terminal.","pgadmin#pgAdmin":"Can be downloaded from here. pgAdmin is a graphical user interface for PostgreSQL. It allows you to create and manage databases, tables, views, etc. It can be useful if you want to learn more about PostgreSQL, but it is probably not needed for this project. We recommend using the CLI, Prisma Studio or the VSCode extension instead."}},"/setup/terminal":{"title":"Terminal","data":{"":"This next section is primarily based on personal preference, though it might be worthwhile to follow along if you're new to WSL (or Linux). By default, Ubuntu comes with the Unix shell called Bash.","what-is-zsh#What is Zsh?":"Zsh (or Z shell) is an extended version of the Bourne Shell (sh), with new features, and support for plugins and themes. In addition, ZSH has many of the same features as bash, so switching won't be a hassle. We will use the Oh My Zsh framework to manage our ZSH configuration, powerlevel10k as our theme, and zsh-autosuggestions for fish-like autosuggestions.\nMacOS' default shell is zsh. If you're on macOS, you can skip the next section.","installing-zsh#Installing Zsh":"First, let's install Zsh:\nsudo apt install zsh\nWe can verify our installation by running zsh --version, which should yield an output of the version number. Next, we need to make it our default shell:\nchsh -s $(which zsh)\nAfter that restart your terminal, and test if it worked with echo $SHELL, it should output /usr/bin/zsh.","oh-my-zsh#Oh My Zsh":"Next, we can install Oh My Zsh:\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\nThe configuration stored in .zshrc can be viewed using cat ~/.zshrc or edited using VS Code using code ~/.zshrc. Here you will find such configuration as ZSH_THEME, and plugins. The theme I really like is called powerlevel10k. Before installation, they recommend to set up their font (this is optional). Install the theme by cloning the repository (for Oh My Zsh users):\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\nThen set ZSH_THEME=\"powerlevel10k/powerlevel10k\" in ~/.zshrc, and restart ZSH with exec zsh. Finally, the configuration wizard will show (otherwise run p10k configure).To further improve the ZSH experience, we can also opt for the zsh-autosuggestions plugin. To install (for Oh My Zsh users):\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\nThen add it to the plugins list inside ~/.zshrc:\nplugins=(\n# other plugins...\nzsh-autosuggestions\n)"}},"/setup/wsl":{"title":"Wsl","data":{"":"A guide to get Windows Subsystem for Linux (WSL) up and running for web development. It will cover setting up the WSL environment, and all the tools needed.","prerequisites#Prerequisites":"This guide assumes you are on a recent build of Windows (20262+, and preferably Windows 11). The guide has been tested for Microsoft Windows Version 22H2 (OS Build 22621.963). To check your version and build number, select WIN + R, type winver, and select OK. Furthermore, if you prefer a different Linux distribution other than Ubuntu, please refer to the sources below.With Windows 11, Windows Terminal is installed by default. If you do not have Windows Terminal, please follow this guide to do so.","get-started#Get started":"Open PowerShell, and enter:\nwsl --install\nThis enables the WSL and Virtual Machine Platform components, downloads and installs the latest Linux kernel, sets WSL 2 as the default, and downloads and installs the Ubuntu Linux distribution.You will need to restart your machine to complete the installation process.","set-up-linux#Set up Linux":"After the restart a terminal window will open to setup your Linux distribution. Now you will be asked to create username and password.\nThese credentials have no bearing on your Windows username and password.\nNote that whilst entering the password, nothing will appear on screen (blind typing).\nThis will be the default user, and considered the Linux administrator, with the ability to run sudo (Super User Do) commands.\n\nTo change or reset your password find more information here.It is recommended to keep your packages up-to-date. So after we reach the login screen we update and upgrade:\nsudo apt update && sudo apt upgrade","learning-more#Learning more":"Installing and using WSL can be daunting at first, especially if you have never used a unix-like operating system before. To help you get started, here are some resources:\nLinux Journey\nLinux Command Line Basics\nLinux Handbook\n\nWhile not required, it would be useful to at least have a basic understanding of the Linux command line. This will help you navigate the file system, and install and configure the tools you need."}},"/setup/yarn":{"title":"Yarn","data":{"":"By default Node.js comes with a package manager called Node Package Manager (NPM). However, we use the Yarn package manager. To install:\nnpm install --global yarn\nCheck your installation using yarn --version."}},"/workflow/commands":{"title":"Commands","data":{"":"Both the frontend and backend have some scripts that you will need to use to get things up and running. We'll quickly discuss some of these scripts, where to find them, how and when to use them and some other non-project specific scripts you might find useful.","where-to-find-the-scripts#Where to find the scripts":"Since both our frontend and backend projects are using Node, the scripts are in the same place for both, namely our package.json file. This is the same file that keeps track of the dependencies of our projects. You can find this file in the root of both the frontend and backend folders. The scripts are specified under the \"scripts\" key.","how-to-use-the-scripts#How to use the scripts":"For the scripts found in the package.json file, you can run them by typing yarn <script-name>. For example, if you want to run the backend in such a way that it restarts on every file change, you would run yarn start:dev. If you want to run the frontend in development mode, you would run yarn dev.","backend-scripts#Backend scripts":"The backend has some scripts that come standard with NestJS as well as some scripts needed for database management. The useful scripts are:\nbuild: Builds the backend for production and checks for any type errors\nformat: Formats the code using Prettier\nlint: Lints and fixes the code using ESLint, this is required to pass before your PR can be merged\nlint:check: Lints the code without applying any fixes\nstart:dev: Starts the backend in development mode, this will restart the backend on every file change\ntest: Runs all tests (unit and e2e)\ntest:spec: Runs all unit tests, can supply a pattern to run specific tests\ntest:e2e: Runs all e2e tests, can supply a pattern to run specific tests\nnews.e2e-spec.ts: Runs the e2e test file named news.e2e-spec.ts\nnews: Runs all e2e test files that contain the pattern news\n-t 'PATTERN': Runs all e2e test cases that contain the pattern PATTERN.\nA use case example might be the following. Say you want to run a test called 'should fail if the user does not have the required roles' in the news.e2e-spec.ts file. You would run yarn test:e2e news -t 'should fail if the user does not have the required roles'.\n\n\n\ndb:migration: Runs a database migration if you have made changes to the schema\ndb:gen: Runs Prisma's type generation script, necessary if your Prisma types are out of date\ndb:seed: Runs the seed script, this will populate the database with some dummy data\ndb:sync: Drops your local database and recreates it from scratch, this will also run the seed script\n\nIf you create a PR, there are certain actions that need to pass before your PR can be merged. These actions are:\nbuild\nlint\ntest\n\nBefore creating a PR, we suggest first running these actions locally to make sure that they pass. If they do not pass, you can still create a PR, but you will need to fix the issues before your PR can be merged.For the database scripts, you'll need to run yarn db:migration if you have made any changes to the Prisma schema file and want these to be reflected in the database. This will also automatically regenerate the Prisma types. You might need to run yarn db:gen if, for whatever reason, you find that your Prisma types do not match the schema. If you do not have the seeded data (such as some default users) in your database, you can run yarn db:seed to populate the database with this data. If something went horribly wrong with your local database, or you just want to sync your database with the latest schema, you can run yarn db:sync which will entirely drop your local database and recreate it from scratch, note that any data you have in your local database will be lost.","frontend-scripts#Frontend scripts":"dev: Starts the frontend in development mode, this will restart the frontend on every file change\nbuild: Builds the frontend for production and checks for any type errors\nstart: Starts the frontend in production mode\nlint: Lints the code using ESLint, this is required to pass before your PR can be merged\ngen: Generates the GraphQL types and queries from the schema and .graphql files\n\nLike the backend, the frontend also has some actions that are required to pass before any PR can be merged, these actions are:\nlint\nbuild\n\nBefore creating a PR, we suggest first running these actions locally to make sure that they pass. If they do not pass, you can still create a PR, but you will need to fix the issues before your PR can be merged.If you are creating additional GraphQL queries, mutations or fragments or if the schema has changed on the backend, you will need to run yarn gen to regenerate the GraphQL types and queries. This will also tell you if there are any errors in your queries, mutations or fragments.","other-useful-scripts#Other useful scripts":"","docker#Docker":"When developing using Docker, it is useful to know the CLI scripts that are available to you. Below are the script you might want to use when developing.\ndocker compose COMMAND --help: For more information on a command.\ndocker compose up: Creates and starts containers.\nCONTAINER: The name of the container you want to start. If you want to start all containers, you can omit this argument.\nThis can be useful when dealing with migrations. In that case you only want to run the database, so you would run docker compose up postgres -d. Then handle all migration actions.\n\n-d: Detached mode: Run containers in the background\n--build: Build images before starting containers.\nUse this if you have added new dependencies to your project.\n\n-V: Recreate anonymous volumes instead of retrieving data from the previous containers.\n\n\ndocker compose down: Stops containers and removes containers, networks, volumes, and images created by up.\n-v: Remove named volumes declared in the volumes section of the Compose file and anonymous volumes attached to containers.\nUse this if you want to reset the database."}},"/workflow/git-conventions":{"title":"Git Conventions","data":{"":"","the-main-branch#The main branch":"The main branch consists of all the code that has been squashed and merged through a pull request. The idea is that all code on main works. It is not possible to directly push code to this branch.","branch-naming#Branch naming":"We follow this branch naming structure:\n<issue_id>-<description>\n# or\nfeat/<description>\n# or\nfix/<description>\nIn Git, we can use the shorthand to checkout and create a branch:\ngit checkout -b <branch>","committing-code-to-the-repository#Committing code to the repository":"All commits must follow the Conventional Commits specification. The commit message should be structured as follows:\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\nHere, the types can be as follows: fix, feat, build, chore, ci, docs, style, refactor, perf or test. Furthermore, make sure that the commit message length does not exceed 50 characters. An example commit would look something like this:\nfeat(activity): allow user to register\n​\nThis adds the logic for activity registration and stores the ActivityRegistration to the database."}},"/workflow":{"title":"Index","data":{"":"To get familiar with the way we go from 0 to completing an issue, we've created a step-by-step guide. But first: what does it mean to complete an issue?","definition-of-done#Definition of done":"A term taken from the Scrum methodology, it's a set of criteria that must be met before a task (issue) is considered completed.\nAn issue is said to be done once a pull request has been created and approved, and all checks pass, or more simply the PR resolving the issue is ready to be merged by one of the CODEOWNERS.","1-setup#1. Setup":"First, make sure you have gone through everything under Learning and Setup.","2-checkout-the-code#2. Checkout the code":"Using the terminal navigate to the folder where you keep your repositories locally. We recommend using the following folder structure:\n~/repositories/<organisation>/<repository>\n\nIn this case the organisation would be fellenoord, and the repository is one were are about to clone from the remote. If you use the same folder structure navigating to there goes as follows: cd ~/repositories/fellenoord.\nClone the repository using git (we'll use the backend as example here). You can find this link at the repository page at GitHub.\n\n\ngit clone git@github.com:Fellenoord/fellenoord-api.git","3-setting-up-the-dependencies#3. Setting up the dependencies":"For the development at the WebCie we universally use the yarn. To get all the dependencies downloaded simply run:\nyarn install\n\n# shorthand\nyarn\nThis will create a node_modules folder with all the dependencies required to develop locally.","4-running-the-application#4. Running the application":"For all applications we provide a README.md file in which we tell you how to run the application. Make sure to read that file!","5-choosing-an-issue#5. Choosing an issue":"To keep track of work we use the GitHub projects feature. Simply pick an issue from the 'Ready for work' column on the WebCie planning project board. In the issue itself, put yourself as assignee. Then, if you're ready to make changes, move the card to the 'In progress' column.","6-making-changes#6. Making changes":"Now that we've chosen an issue we want to work on there are some essential steps.","create-a-branch#Create a branch":"To ensure code quality in all of our repositories, we work with protected branches. For each repository the main branch is the protected branch. This means that no code can be directly pushed to that branch, making sure that code is first reviewed. So when making changes we always work on a separate branch. To create a branch locally:\ngit checkout -b <name>","commit-changes#Commit changes":"After you've make some changes, we can commit those changes.\nIt is important to realise that (especially when working on larger issues) it is recommended to periodically commit your code. For two reasons: making the review of the PR easier, and allowing for rollback to a certain commit when certain changes don't work out. To see what changes you've made:\n\ngit status\nThen stage the files for commit.\n# All all files.\ngit add .\n\n# Add specific file(s).\ngit add <path-to-file-or-directory>\nFinally, we can commit the changes.\nPlease adhere to the git conventions.\n\ngit commit -m \"feat(topic): awesome description for feature\"","push-changes#Push changes":"The only thing left is to push your changes from the local git repository to the remote.\ngit push","7-review#7. Review":"","creating-a-pr#Creating a PR":"Now that you have pushed your changes to your own branch, you are ready to create a pull request (PR). To do so, head over to the repository's page on GitHub and click on the 'Pull requests' tab. Then click on the 'New pull request' button. In here, you can select the branch you want to merge into our main branch. You should also take note of the following things:\nMake sure to pick a title that is descriptive of the changes you've made\nMake sure to mention in the description which issue you are closing (i.e. Closes #<issue-number>)\nMake sure to assign yourself to the PR (can be done on the right)\n\nOnce everything is ready, you can choose to create the PR directly or as a draft. If you choose to create it as a draft, you can still make changes to the PR before it is ready to be merged. Reviewers will automatically be assigned and notified of the PR.","fixing-requested-changes#Fixing requested changes":"After a codeowner has reviewed your PR, they might request some changes. It might also be the case that certain required actions fail. In this case, you should make the requested changes and push them to the branch. Once you have made the necessary changes, do not forget to push them to the branch as well as to ask for a new review. If you do not ask for a new review, the codeowner might not be notified of the changes you've made.","reviewing-a-pr#Reviewing a PR":"While this might not be immediately relevant for everyone, it might be the case that you are asked to review a PR. When reviewing a PR, you should take the following things into account:\nDoes the PR close the issue it is supposed to close?\nDoes the PR adhere to our style conventions? (this is also partially checked by the linting action)\nAre there any changes that are not necessary for the PR? (i.e. changes to files that are not related to the issue)\nDoes the PR have a proper description ? (i.e. does it mention the issue it closes)\nDoes the PR introduce any breaking changes? (i.e. changes that might break other parts of the application)\n\nIt might be wise to test the PR locally to see if it works as intended. If you have any questions, you can always ask the author of the PR. Also make sure to use the tools provided by GitHub to make the review as clear and concise as possible, i.e. using code suggestions.","merging-code#Merging code":"This action can only be done by one of the CODEOWNERS.\nWhen the PR is finished and approved, we can merge the code to be on the main branch."}},"/workflow/troubleshooting":{"title":"Troubleshooting","data":{"":"During development, you will probably encounter many errors. This page will help you understand and troubleshoot some of the more common errors specific to this project. There are also some general errors as well as tips and tricks that can help you to more easily debug your code.This page will be updated as we encounter more errors. If you encounter an error that is not listed here, please feel free to open an issue or a pull request to add it to this page.","backend#Backend":"","nestjs-circular-dependencies#NestJS circular dependencies":"If you are getting an error that looks like this:\n[Nest] 1   - 2020-10-05 11:00:00   [ExceptionHandler] Nest cant resolve dependencies of the CatsService (?). Please make sure that the argument at index [0] is available in the CatsModule context.\nYou are probably running into a circular dependency. This is a common problem in NestJS and can be solved by using forwardRef. However, before we can solve this, we have to find out where the circular dependency is. To do this, we can use the carefully read the error to see where we can find the offending module. In the case of our error, we can see that the error is coming from the argument at index [0] of the CatsService. If our CatsService were to look like this:\n@Injectable()\nexport class CatsService {\nconstructor(private commonService: CommonService) {}\n}\nThen we would know that the error is coming from the CommonService, since CommonService is at index 0 of our CatsService constructor method. We should be importing the CommonModule in our CatsModule, which would look like this:\n@Module({\nimports: [CommonModule],\nproviders: [CatsService],\n})\nNow, we can use NestJS' forwardRef function to resolve the circular dependency as follows:\n@Module({\nimports: [forwardRef(() => CommonModule)],\nproviders: [CatsService],\n})\nDo not forget to also do the same in the CommonModule. More information about circular dependencies in NestJS can be found in the NestJS documentation.","graphql-type-is-defined-in-resolvers-but-not-in-schema#GraphQL type is defined in resolvers but not in schema":"If you are getting an error talking about a type being defined in your resolvers but not in your schema, you are likely missing a @Query or @Mutation function in your resolver. You cannot resolve fields on an object without having at least one @Query or @Mutation function that returns that object.","prisma-is-missing-properties-on-my-type#Prisma is missing properties on my type":"If you have just updated your Prisma schema and created a migration, but the added property is not reflected in Prisma's TypeScript type, it's likely that your Prisma types are out of date. To fix this, you can run yarn db:gen to regenerate the Prisma types. Depending on the size of the schema and your local machine, it may take a few seconds for your IDE to pick up the new types, if you are using VSCode, you can try restarting the TS server by running TypeScript: Restart TS Server from the command palette.","resolver-fields-are-not-showing-up-in-graphql-schema#Resolver fields are not showing up in GraphQL schema":"If you have added new fields to a resolver but you cannot find them in your GraphQL schema, it's likely that you forgot to add your Resolver to the NestJS module. You can do this by adding the resolver to the providers array in the module's @Module decorator. Also don't forget to add the module to the imports array of the app module.","frontend#Frontend":"","graphql-fragment-is-missing-properties#GraphQL fragment is missing properties":"If you have just added new .graphql files or have added a new field to an existing file, you might find that the new property is not appearing in the generated TypeScript types. If this is the case, make sure you have run yarn gen to generate TypeScript types for your GraphQL schema and files. If the changes are still not appearing, your IDE is likely struggling to pick up the new types. In VSCode, you can try restarting the TS server by running TypeScript: Restart TS Server from the command palette or opening the generated file and let VSCode pick up the new types.","in-general#In general":"Here are some general tips and tricks that can help you to debug your code. Ideally, these are followed in order, but feel free to skip a step or two if you don't have the time or don't think it's necessary.","log-intermediate-values#Log intermediate values":"If you are unsure why something is not working, try logging the value of the variable you are working with. This can help you to understand what is going on and can help you to find the source of the problem. You can use console.log to log the variable, if your value is an object, you might prefer to use console.log({ value }) or console.log(JSON.stringify(value, null, 2)) to get a more readable output.","read-the-error-message#Read the error message":"The error message is usually the best place to start when debugging. It will usually tell you exactly what is wrong and where the problem is. In the case of TypeScript errors, the error message will not always be the most helpful, but it will usually give you a good idea of where to look.","google-is-your-friend#Google is your friend":"If you are still stuck, try googling the error message. You will likely find a lot of helpful information on StackOverflow and other sites. If you are still stuck, try to rephrase your question and try again. Also make sure to include relevant keywords in your search, such as the name of the framework you are using.","consult-the-documentation#Consult the documentation":"If you are still stuck, try to consult the documentation for the framework you are using. The documentation is usually very well written and will help you to understand what is going on.","ask-for-help#Ask for help":"If you exhausted all of your options and are still stuck, don't be afraid to ask others for help! You can join the Discord server and ask for help in the #help channel. Please include as much information as possible, such as the error message, the code you are working with, and any other relevant information. If you are not in the Discord server yet, please ask for an invite."}},"/workflow/graphql":{"title":"GraphQL","data":{"":"While you might be familiar with REST APIs, you might not be familiar with GraphQL. GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. If you are not yet familiar with the basics of GraphQL, please refer to the backend skills page.We'll go over the general structure of GraphQL, how we apply it in our API and how to write GraphQL resolvers using our conventions.","graphql-structure#GraphQL structure":"GraphQL APIs are structured as a graph of nodes and edges. The nodes are the data types and the edges are the relationships between them. The edges are defined by the fields of the nodes. For example, a User node might have a posts field that is a list of Post nodes. The Post node might have a comments field that is a list of Comment nodes. The Comment node might have a user field that is a User node.In the case of our project, we have a TrainingPeriod node that has a groups field that is a (paginated) list of TrainingGroup nodes, which have a trainings field that is a (paginated) list of Training nodes. Each Training also contains a date field that is a Date node.Each of these things can also be found in our codebase. The TrainingPeriod node is defined in our dto file: src/training/period/dto/training-period.object.ts. Notice the @ObjectType notation which defines a GraphQL object in NestJS. In the training period dto, you can see only 2 fields: id and isPublished. However, earlier we mentioned that the TrainingPeriod node has a groups field that is a list of (paginated) TrainingGroup nodes. To find these groups, we have to go to the TrainingGroupPeriodResolver found in src/training/group/training-group.period.resolver.ts. In here, we'll find a @ResolveField that returns a PaginatedTrainingGroupsObject. This function allows a user to query a TrainingPeriod in our API and resolve a field called groups that resolves as a paginated list of TrainingGroup nodes. If the top-level for query is called period (which can be found in our TrainingPeriodResolver in src/training/period/training-period.resolver.ts), our groups query would look like this:\nquery GetPeriodGroups($periodId: String!) {\nperiod(id: $periodId) {\ngroups {\nedges {\nnode {\nid\n}\n}\n}\n}\n}\n\nIf you are curious as to why we are cannot directly query a TrainingGroup node from groups, you can read more about the pagination specification here.\nIf you have read up on GraphQL, you should be familiar with this query notation. We are creating a query called GetPeriodGroups that takes 1 argument, periodId which is of type String (the ! means that it is required). The query will return a period node that has a groups field that is a paginated list of TrainingGroup nodes. Each TrainingGroup node has an id field.In general, we want to nest objects to reflect our relationships in the database. So instead of having a query for group, you can only query a group through a period. This is because a group is only related to a period and not to any other object. If you want to query a group, you must first query a period and then query the group through the period. Mutations, on the other hand, are not nested. This is because mutations are used to create, update or delete objects. If you want to create a group, you can do so without having to query a period first.","how-to-write-resolvers#How to write resolvers":"In the previous example, we saw that we are resolving field on a TrainingPeriod via the TrainingGroupPeriodResolver. Notice that this is not the same resolver as our period query, which is TrainingPeriodResolver. While both resolvers are resolvers for the type TrainingPeriodObject, we deliberatly chose to split them up. This is because we want to keep our resolvers small and focused on a single task. This makes it easier to maintain and test our code. This also helps with keeping down the number of circular dependencies in NestJS since you won't need to import the TrainingGroupService within the TrainingPeriodModule this way.In general, if you are resolving fields for other objects, you should create a new resolver for that object within the module of that object.\nOur convention is to name the resolver CurrentObject.ObjectToResolveOn.resolver.ts. In the case of our TrainingGroupPeriodResolver, we are resolving the groups field on a period, so we named it training-group.period.resolver.ts.\nFor queries and mutations, on the other hand, you are free to use the same resolver as the object you are querying or mutating. In the case of our TrainingPeriodResolver, we are querying a period and so we named it training-period.resolver.ts. This also makes the most sense since we can use our TrainingPeriodService, which is in the same module as our resolver, to both query and mutate periods.\nOur convention is to name the resolver CurrentObject.resolver.ts. In the case of our TrainingPeriodResolver, we are querying a period, so we named it training-period.resolver.ts.","avoid-top-level-queries-for-nested-objects#Avoid top-level queries for nested objects":"With our TrainingGroupPeriodResolver, we are resolving the training groups on a TrainingPeriod. However, this adds more complexity to our groups query since we now need to query a period first. While we could have added a top-level query for groups, we decided against it. This is because we want to keep our API as simple as possible. We want to avoid having to query multiple objects to get the data you want. This is why we decided to nest the groups field on the period query. This way, you can query a period and get the groups through that period. This is also why we decided to nest the trainings field on the group query. This way, you can query a group and get the trainings through that group.You can, however, create some shortcuts. In our case, we have resolve a myTrainings field directly on a TrainingPeriod. This is both because we want to make it a little easier for the frontend to query the trainings for the current user and because we a user's training might span multiple groups. Another example of such a shortcut is the currentPeriod query. This is a top-level query that returns the current period. This is because we want to make it easier for the frontend to query the current period.Keep in mind that this advise does not hold for mutations, since you can't nest mutations. If you want to create a training, it has to be done through a top-level mutation. In the end, a top-level query should only be added if the object is standalone with no parent relationship. If the object is related to another object, you should nest the query (as a resolved field) on that object."}},"/learning/programming":{"title":"Programming","data":{"":"Since everyone prefers a different way to learn, we make a distinction between interactive courses, documentation and video tutorials. However, there are not always free resources available for all of these, so we have made a selection of the best free resources (in our opinion) for each of these categories.","absolute-beginner#Absolute beginner":"If you have never programmed before in your life, it might be a little difficult to get started, since JavaScript (or TypeScript) is not the easiest or most straight-forward language to learn. Nevertheless, here are some resources you can use to get started:\nJavaScript docs\nBasic JavaScript (freeCodeCamp)\nFull Stack course\nYouTube JavaScript crash course\n\nIf you feel like JavaScript is not a good starting point, you might want to consider learning a different language first. For example, Python is a very popular language for beginners, and it is also used in many data science applications. You can find a lot of resources for Python on the internet, but here are some of our favorites:\nPython Beginner's Guide\nPython for Everybody (freeCodeCamp)\n\nWhile the syntax for Python is quite different from JavaScript, the concepts are very similar. So if you learn Python first, you will have an easier time learning JavaScript later on.","have-done-some-programming-before#Have done some programming before":"Whether you have done some programming in JavaScript, Java or Python, the fundamentals are mostly the same. It is, however, important that you become familiar with the JavaScript syntax and also start grasping the fundamentals of TypeScript and Node.js. In essence, TypeScript is a superset of JavaScript, so you can use JavaScript in TypeScript, but you can also use some of the more advanced features of TypeScript. Node.js is a JavaScript runtime environment, which means that you can run JavaScript code outside of the browser. Here are some resources to help you learn both:\nJavaScript Tutorial\nIntroduction to Node.js\nTypeScript Handbook\n\nIf you have not used JavaScript before, we also recommend looking at the section above for absolute beginners to get a good foundation.Please note that Node.js setup is covered in the setup section of this guide.","have-used-typescript-before#Have used TypeScript before":"If you have used TypeScript before, chances are that you are already familiar with Node.js. If you are not, please look at the section above to familiarize yourself with Node.js. If you understand the basics of TypeScript, you should be good to get started with the next sections of this guide.","where-to-go-from-here#Where to go from here":"Now that you have a good foundation, you can start looking at the backend section or frontend section. We highly recommend that you start with the backend section, since it is the most important part of the application. If you are not interested in the backend, you can also start with the frontend section, but you will probably have to learn the backend later on anyway."}}}